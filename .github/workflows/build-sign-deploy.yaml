name: Build, Sign & Deploy

on:
  push:
    branches: [main]
    paths:
      - 'app/**'
      - 'k8s/**'
      - '.github/workflows/build-sign-deploy.yaml'
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  packages: write
  security-events: write

jobs:
  build-and-sign:
    name: Build and Sign Image
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-uri: ${{ steps.build.outputs.image-uri }}
      image-tag: ${{ steps.build.outputs.image-tag }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ECR_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Image
        id: build
        run: |
          IMAGE_TAG="${{ github.sha }}"
          IMAGE_URI="${{ secrets.ECR_REGISTRY }}/secure-flask-poc:${IMAGE_TAG}"
          
          # Build and push for AMD64 architecture
          docker buildx build --platform linux/amd64 --push -t ${IMAGE_URI} ./app || exit 1

          # Get image digest from registry
          DIGEST=$(docker buildx imagetools inspect ${IMAGE_URI} --format '{{json .}}' | jq -r '.manifest.digest')
          
          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          
          echo "Built image: ${IMAGE_URI}"
          echo "Image digest: ${DIGEST}"

      - name: Sign Image with Cosign
        run: |
          IMAGE_URI="${{ secrets.ECR_REGISTRY }}/secure-flask-poc:${{ github.sha }}"
          cosign sign --yes ${IMAGE_URI}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Install Syft
        run: |
          curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin

      - name: Generate SBOM
        run: |
          IMAGE_URI="${{ secrets.ECR_REGISTRY }}/secure-flask-poc:${{ github.sha }}"
          syft ${IMAGE_URI} -o spdx-json > sbom.json || exit 1
          cosign attest --yes --predicate sbom.json ${IMAGE_URI} || exit 1

      - name: Verify Signature
        run: |
          IMAGE_URI="${{ secrets.ECR_REGISTRY }}/secure-flask-poc:${{ github.sha }}"
          echo "Verifying image: ${IMAGE_URI}"
          cosign verify --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            ${IMAGE_URI}
        env:
          COSIGN_EXPERIMENTAL: 1

  # security-scan:
  #   name: Security Scan
  #   runs-on: ubuntu-latest
  #   needs: build-and-sign
  #   permissions:
  #     contents: read
  #     id-token: write
  #     security-events: write
  #   steps:
  #     - name: Configure AWS credentials
  #       uses: aws-actions/configure-aws-credentials@v4
  #       with:
  #         role-to-assume: ${{ secrets.AWS_ECR_ROLE_ARN }}
  #         aws-region: ${{ secrets.AWS_REGION }}

  #     - name: Login to ECR
  #       uses: aws-actions/amazon-ecr-login@v2

  #     - name: Debug Image Reference
  #       run: |
  #         echo "Image tag: ${{ needs.build-and-sign.outputs.image-tag }}"
  #         echo "Image URI: ${{ needs.build-and-sign.outputs.image-uri }}"

  #     - name: Run Trivy Security Scan
  #       uses: aquasecurity/trivy-action@0.29.0
  #       with:
  #         image-ref: ${{ needs.build-and-sign.outputs.image-tag }}
  #         format: 'sarif'
  #         output: 'trivy-image-results.sarif'
  #         severity: 'HIGH,CRITICAL'
  #         exit-code: 0

  #     - name: Upload Trivy Scan Results
  #       if: always() && hashFiles('trivy-image-results.sarif') != ''
  #       uses: github/codeql-action/upload-sarif@v3
  #       with:
  #         sarif_file: 'trivy-image-results.sarif'

  # deploy:
  #   name: Deploy to Kubernetes
  #   runs-on: ubuntu-latest
  #   needs: [build-and-sign, security-scan]
  #   if: github.ref == 'refs/heads/main'
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4

  #     - name: Setup kubectl
  #       uses: azure/setup-kubectl@v3

  #     - name: Setup kind cluster
  #       uses: helm/kind-action@v1
  #       with:
  #         cluster_name: secure-poc

  #     - name: Install OPA Gatekeeper
  #       run: |
  #         kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/release-3.14/deploy/gatekeeper.yaml
  #         kubectl wait --for=condition=Ready pods -l control-plane=controller-manager -n gatekeeper-system --timeout=300s

  #     - name: Apply Security Policies
  #       run: |
  #         kubectl apply -f k8s/policies/
  #         sleep 30  # Wait for policies to be ready

  #     - name: Deploy Application
  #       run: |
  #         # Update image in deployment
  #         sed -i "s|IMAGE_PLACEHOLDER|${{ needs.build-and-sign.outputs.image-uri }}|g" k8s/app/deployment.yaml
  #         kubectl apply -f k8s/app/

  #     - name: Verify Deployment
  #       run: |
  #         kubectl wait --for=condition=Ready pods -l app=secure-flask-poc --timeout=300s
  #         kubectl get pods -l app=secure-flask-poc
  #         kubectl get services

  #     - name: Run Security Verification
  #       run: |
  #         # Verify image signature in cluster
  #         kubectl get pods -l app=secure-flask-poc -o jsonpath='{.items[0].spec.containers[0].image}' | \
  #         xargs cosign verify --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
  #           --certificate-oidc-issuer=https://token.actions.githubusercontent.com

  #     - name: Port Forward and Test
  #       run: |
  #         kubectl port-forward service/secure-flask-poc 8080:80 &
  #         sleep 5
  #         curl -f http://localhost:8080/health || exit 1
  #         echo "✅ Application is healthy"

  deploy-ecs:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    needs: build-and-sign
    if: github.ref == 'refs/heads/main'
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_TERRAFORM_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Validate Image Signature
        run: |
          IMAGE_URI="${{ secrets.ECR_REGISTRY }}/secure-flask-poc:${{ github.sha }}"
          cosign verify --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            ${IMAGE_URI}
          echo "✅ Image signature validated successfully"
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Update ECS Task Definition
        run: |
          IMAGE_URI="${{ secrets.ECR_REGISTRY }}/secure-flask-poc:${{ github.sha }}"
          
          # Get current task definition
          TASK_DEF=$(aws ecs describe-task-definition --task-definition flask-app --region ${{ secrets.AWS_REGION }}) || exit 1
          
          # Update image URI
          NEW_TASK_DEF=$(echo $TASK_DEF | jq --arg IMAGE "${IMAGE_URI}" '.taskDefinition | .containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes) | del(.placementConstraints) | del(.compatibilities) | del(.registeredAt) | del(.registeredBy)') || exit 1
          
          # Validate jq output
          if [ "$NEW_TASK_DEF" = "null" ] || [ -z "$NEW_TASK_DEF" ]; then
            echo "Error: Failed to parse task definition"
            exit 1
          fi
          
          # Register new task definition
          aws ecs register-task-definition --region ${{ secrets.AWS_REGION }} --cli-input-json "$NEW_TASK_DEF" || exit 1
          
          # Update service
          aws ecs update-service \
            --cluster flask-poc \
            --service flask-service \
            --task-definition flask-app \
            --region ${{ secrets.AWS_REGION }} || exit 1

      - name: Wait for deployment
        run: |
          aws ecs wait services-stable \
            --cluster flask-poc \
            --services flask-service \
            --region ${{ secrets.AWS_REGION }}

      - name: Verify deployment
        run: |
          echo "✅ ECS service updated successfully"
