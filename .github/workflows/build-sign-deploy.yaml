name: Build, Sign & Deploy

on:
  push:
    branches: [main]
    paths:
      - 'app/**'
      - 'k8s/**'
      - '.github/workflows/build-sign-deploy.yaml'
  workflow_dispatch:

permissions:
  contents: read
  id-token: write
  packages: write
  security-events: write

jobs:
  build-and-sign:
    name: Build and Sign Image
    runs-on: ubuntu-latest
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-uri: ${{ steps.build.outputs.image-uri }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ECR_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and Push Image
        id: build
        run: |
          IMAGE_TAG="${{ secrets.ECR_REGISTRY }}/secure-flask-poc:${{ github.sha }}"
          
          docker build -t ${IMAGE_TAG} -t ${LATEST_TAG} ./app
          docker push ${IMAGE_TAG}

          # Get image digest
          DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${IMAGE_TAG} | cut -d'@' -f2)
          IMAGE_URI="${{ secrets.ECR_REGISTRY }}/secure-flask-poc@${DIGEST}"

          echo "digest=${DIGEST}" >> $GITHUB_OUTPUT
          echo "image-uri=${IMAGE_URI}" >> $GITHUB_OUTPUT
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT

      - name: Sign Image with Cosign
        run: |
          # Use keyless signing with GitHub OIDC
          cosign sign --yes ${{ steps.build.outputs.image-uri }}
        env:
          COSIGN_EXPERIMENTAL: 1

      - name: Generate SBOM
        run: |
          # Generate Software Bill of Materials
          cosign attest --yes --predicate <(syft ${{ steps.build.outputs.image-uri }} -o spdx-json) ${{ steps.build.outputs.image-uri }}

      - name: Verify Signature
        run: |
          cosign verify --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
            --certificate-oidc-issuer=https://token.actions.githubusercontent.com \
            ${{ steps.build.outputs.image-uri }}

  security-scan:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-and-sign
    permissions:
      contents: read
      id-token: write
      security-events: write
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ECR_ROLE_ARN }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Run Trivy Security Scan
        uses: aquasecurity/trivy-action@0.29.0
        with:
          image-ref: ${{ needs.build-and-sign.outputs.image-tag }}
          format: 'sarif'
          output: 'trivy-image-results.sarif'
          severity: 'HIGH,CRITICAL'
          exit-code: 0

      - name: Upload Trivy Scan Results
        if: always() && hashFiles('trivy-image-results.sarif') != ''
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-image-results.sarif'

  # deploy:
  #   name: Deploy to Kubernetes
  #   runs-on: ubuntu-latest
  #   needs: [build-and-sign, security-scan]
  #   if: github.ref == 'refs/heads/main'
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4

  #     - name: Setup kubectl
  #       uses: azure/setup-kubectl@v3

  #     - name: Setup kind cluster
  #       uses: helm/kind-action@v1
  #       with:
  #         cluster_name: secure-poc

  #     - name: Install OPA Gatekeeper
  #       run: |
  #         kubectl apply -f https://raw.githubusercontent.com/open-policy-agent/gatekeeper/release-3.14/deploy/gatekeeper.yaml
  #         kubectl wait --for=condition=Ready pods -l control-plane=controller-manager -n gatekeeper-system --timeout=300s

  #     - name: Apply Security Policies
  #       run: |
  #         kubectl apply -f k8s/policies/
  #         sleep 30  # Wait for policies to be ready

  #     - name: Deploy Application
  #       run: |
  #         # Update image in deployment
  #         sed -i "s|IMAGE_PLACEHOLDER|${{ needs.build-and-sign.outputs.image-uri }}|g" k8s/app/deployment.yaml
  #         kubectl apply -f k8s/app/

  #     - name: Verify Deployment
  #       run: |
  #         kubectl wait --for=condition=Ready pods -l app=secure-flask-poc --timeout=300s
  #         kubectl get pods -l app=secure-flask-poc
  #         kubectl get services

  #     - name: Run Security Verification
  #       run: |
  #         # Verify image signature in cluster
  #         kubectl get pods -l app=secure-flask-poc -o jsonpath='{.items[0].spec.containers[0].image}' | \
  #         xargs cosign verify --certificate-identity-regexp="https://github.com/${{ github.repository }}" \
  #           --certificate-oidc-issuer=https://token.actions.githubusercontent.com

  #     - name: Port Forward and Test
  #       run: |
  #         kubectl port-forward service/secure-flask-poc 8080:80 &
  #         sleep 5
  #         curl -f http://localhost:8080/health || exit 1
  #         echo "âœ… Application is healthy"
